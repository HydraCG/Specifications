## Searching for events

### Story
As an application user
I want to be able to quickly search through my events
So I find events I'm interested in.

As an API consumer
I want to be able to search through a collection of resources
So I can find those interesting to me.

### Usage
```javascript
var client = new HydraClient();
var collection = client.get("/api/events");
if (colletion.search) {
    var filter = {};
    for (let mapping of collection.search.mappings) {
        filter[mapping.variable] = "some text";
    }

    var query = urlTemplate
        .parse(collection.search.template)
        .expand(filter);
    var data = client.get(query);
    for (var member of data.members) {
        // do something with the _member_, i.e. display it
    }
}
```

### Details
The application should be able to search through events,
so the user can narrow down the number and importance of the events displayed.
This would be simple search scenario without diving into how the
search phrase is interpreted by the server and how it is used while searching.
Communication would look like this:

```http
GET /api/events
```

```http
HTTP 200 OK
```

```json
{
    "@context": "/api/context.jsonld",
    "@id": "/api/events",
    "totalItems": 1,
    "members": [
        {
            "@id": "/api/events/1",
            "eventName": "Event 1",
            "eventDescription": "Some event 1",
            "startDate": "2017-04-19",
            "endDate": "2017-04-19"
        }
    ],
    "search": {
        "@type": "IriTemplate",
        "hydra:template": "http://example.com/api/events{?search}",
        "hydra:variableRepresentation": "hydra:BasicRepresentation",
        "hydra:mapping": [
            {
                "@type": "hydra:IriTemplateMapping",
                "variable": "search",
                "property": "hydra:freetextQuery",
                "required": true
            }
        ]
    }
}
```

```http
GET /api/events?search=some%20text
```

```http
HTTP 200 OK
```

```json
{
    "@context": "/api/context.jsonld",
    "@id": "/api/events?search=some text",
    "totalItems": 1,
    "members": [
        {
            "@id": "/api/events/1",
            "eventName": "Event 1",
            "eventDescription": "Some event having a search phrase",
            "startDate": "2017-04-19",
            "endDate": "2017-04-19"
        }
    ]
}
```

### Considerations

#### How the client would be informed of the search possibility
There are two main sources of that information which can enable client
with a search feature:

- API documentation
- hypermedia controls

Unfortunately, current specification does not clearly state,
how the templated link should be embedded in the payload of both.
There is an example of a templated link using a special
purpose *freetextQuery* property that can be used for search.
There is also a special purpose templated link *search*,
but again it is unclear on how it should be used.
Possible payload for hypermedia control would look like this:
```http
GET /api/events
```

```http
HTTP 200 OK
```

```json
{
    "@context": "/api/context.jsonld",
    "@id": "/api/events",
    "totalItems": 1,
    "members": [
        {
            "@id": "/api/events/1",
            "eventName": "Event 1",
            "eventDescription": "Some event 1",
            "startDate": "2017-04-19",
            "endDate": "2017-04-19"
        }
    ],
    "search": {
        "@type": "IriTemplate",
        "hydra:template": "http://example.com/api/events{?search}",
        "hydra:variableRepresentation": "hydra:BasicRepresentation",
        "hydra:mapping": [
            {
                "@type": "hydra:IriTemplateMapping",
                "variable": "search",
                "property": "hydra:freetextQuery",
                "required": true
            }
        ]
    }
}
```


#### Templated link usage
Following analogy of other predefined links, like *first* for collections,
templated links should be used as predicates:

```turtle
</api/events> hydra:search </api-doc/events#search-iri-template> .
```

Above's example of a triple with a templated link
seems inconvinient as in order to define a custom
templated link, one should create a separate resource.
IRI of that resource shall be nicely foldable to QIri form
in order to improve readability, resulting in a number
of fake namespaces.

Also a location of the template itself within the graph is not clear.
The example above puts it as a related resource of the
*hydra:search* predicate, but only to fill the gap as
there is no other resource that could be used to
build up a valid statement.
Also this seems compliant (again by analogy) to simple scenario
with *first* predicate, where the related resource is another collection page.
