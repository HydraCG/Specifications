## Entry point

### Story
As an application user
I want my application to consume an entry point for the Web API by providing a base URL
So I can start managing my events.

### Usage
```javascript
var client = new HydraClient();
var data = client.get("/api");
for (var control of data.controls) {
    // do something with the _control_
}
```

### Details
We can imaging a situation, when an application has a base URL provided, i.e. in a configuration or in the input field.
Once provided, I'd expect the application to connect to the entry-point of the Web API and download initial
details on what else can be done with that API from that very point.

```
GET /api

HTTP 200 OK
```
```javascript
{
    "@id": "/api",
    "operations": [
        {
            "@id": "/api/events",
            "title": "Events",
            "httpMethod": "GET",
            "returns": "hydra:Collection"
        },
        {
            "@id": "/api/events",
            "title": "Create new event",
            "httpMethod": "POST",
            "expects": "schema:Event"
        }
    ]
}
```

With this details, client application is aware of two possible operations that can be made from that point:

- GET events
- POST an event

We can imagine a UI application with some fancy logic that would takes all
GET operations returning _hydra:Collection_ and displays them in a main menu.

### Considerations

#### JSON array root security issues
Due to security issues with JSON arrays which can be exploited in some circumstances, 
there may be a need to avoid pure arrays in favour of a JSON object.
In the scenario above, server returned a single object, which won't cause issues.
But it is possible to return multiple resources, resulting in an JSON array returned 
(server may not use any JSON-LD context or it may be completely different from the one used by the client).
There are several possibilities here. One of them would be to use a *@graph* notation, i.e.:

```javascript
{
    "@graph": [
        {
            "@id": "/api",
            "operations": [
                {
                    "@id": "/api/events",
                    "title": "Events",
                    "httpMethod": "GET",
                    "returns": "hydra:Collection"
                },
                {
                    "@id": "/api/events",
                    "title": "Create new event",
                    "httpMethod": "POST",
                    "expects": "schema:Event"
                }
            ]
        },
        {
            "rdfs:label": "Some other resource somehow related to the main one."
        }
    ]
}
```

Using default graph seems reasonable, but implies some additional, possibly unwanted,
logic of the graph itself.
We could consider another approach or somehow standardize the graph name (if necessary).

#### Reasoning capabilities
Another thing is how far the client should be pushed into the reasoning process.
In the example above, only _hydra:method_ and _hydra:expects_ predicates were used.
In OWL environment, this is fully legal as the reasoning process would extend the
resource _/events_ with additional statement (in Turtle):

```
</api/events> a hydra:Operation .
```

This is due to fact that Hydra Core Vocabulary provides an _rdfs:domain_ for _hydra:method_ .
Unfortunately, many clients, especially browser based, won't use that process of reasoning,
thus an explicit statement should appear so the client can easily discover all the operations.