<!DOCTYPE html>
<html>
<head>
<title>Hydra Core Vocabulary</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"/>
<script type="text/javascript" src="../../../js/respec-w3c-common.js" class="remove"></script>
<script type="text/javascript" src="../../../js/jsonld.js" class="remove"></script>
<script type="text/javascript" src="../../../js/respec-w3c-extensions.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
  var respecConfig = {
      // extend the bibliography entries
      "localBiblio": localBibliography,

      doRDFa: "1.1",
      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus:           "unofficial",
      // if you wish the publication date to be other than today, set this
      //publishDate:          "2012-08-30",
      copyrightStart:       "2012",

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName:            "hydra-core",
      subtitle:             "A Vocabulary for Hypermedia-Driven Web APIs",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate:  "2012-08-30",
      // previousMaturity:     "FPWD",
      // previousDiffURI:      "http://www.w3.org/TR/2012/WD-json-ld-syntax-20120830/",
      // diffTool:             "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI:           "http://www.markus-lanthaler.com/hydra/spec/latest/core/index.html",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      issueBase: "https://github.com/lanthaler/hydra/issues/",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      // extraCSS:             [],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
          { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
            company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:  [
          { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
            company: "Graz University of Technology", companyURL: "http://www.tugraz.at/" }
      ],

      // name of the WG
      // wg:           "RDF Working Group",

      // URI of the public WG page
      // wgURI:        "http://www.w3.org/2011/rdf-wg/",

      // name (with the @w3c.org) of the public mailing to which comments are due
      // wgPublicList: "public-rdf-comments",

      // URI of the patent status for this WG, for Rec-track documents
      // !!!! IMPORTANT !!!!
      // This is important for Rec-track documents, do not copy a patent URI from a random
      // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
      // Team Contact.
      wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/46168/status",
      maxTocLevel: 4,
      preProcess: [ preProc ]
      //alternateFormats: [ {uri: "diff-20120712.html", label: "diff to previous version"} ]
  };
//]]>
</script>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-36111533-1']);
  _gaq.push(['_setDomainName', 'markus-lanthaler.com']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
<style type="text/css">
  .hlist {
    border: 1px solid navy;
    padding:5px;
    background-color: #F4FFFF;
  }
  .hlist li {
    display: inline;
    display: inline-table;
    list-style-type: none;
    padding-right: 20px;
  }
  .highlight {
    font-weight: bold;
    color: #0a3;
  }
  .comment {
    color: #999;
  }
  .illustration {
    text-align: center;
  }
  #vocabulary-jsonld {
    white-space: pre-wrap;
  }
</style>
</head>

<body>
<section id="abstract">
  <p>Hydra is a lightweight vocabulary to create hypermedia-driven Web APIs.
    By specifying a number of concepts commonly used in Web APIs it enables
    the creation of generic API clients.</p>
</section>

<section id="sotd">
  <p>To participate in the development of this specification please file bugs
    and issues in the <a href="https://github.com/lanthaler/Hydra/issues">issue tracker</a>.</p>
</section>

<section class="informative">
  <h2>Introduction</h2>

  <p>Coping with the ever-increasing amount of data becomes
    increasingly challenging. To alleviate the information overload put on
    people, systems are progressively being connected directly to each
    other. They exchange, analyze, and manipulate humongous amounts of
    data without any human interaction. Most current solutions, however,
    do not exploit the whole potential of the architecture of the World
    Wide Web and completely ignore the possibilities offered by Linked Data
    technologies.</p>

  <p>The combination of the REST architectural style and the Linked
    Data principles offer opportunities to advance the Web of machines
    in a similar way that hypertext did for the human Web. Most
    building blocks exist already and are in place but they are rarely
    used together. Hydra tries to fill that gap. It allows data to be
    enriched with machine-readable affordances which enable
    interaction. This not only addresses the problem that Linked Data
    is still mostly read-only, but it also paves the way for a
    completely new breed of interoperable Web APIs. The fact that it
    enables the creation of composable contracts means that
    interaction models of Web APIs can be reused at an unprecedented
    granularity.</p>
</section>

<section>
  <h2>Conformance</h2>

  <p>This specification describes the conformance criteria for
    <dfn title="Hydra API documentation">Hydra API documentations</dfn>
    and <dfn title="Hydra client">Hydra clients</dfn>. This criteria is
    relevant to authors, authoring tool implementers, and client
    implementers. All authoring guidelines, diagrams, examples, and notes
    in this specification are non-normative, as are all sections
    explicitly marked as non-normative. Everything else in this
    specification is normative.</p>

  <p>The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
    SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
    specification have the meaning defined in [[!RFC2119]].</p>
</section>

<section class="informative">
  <h2>Hydra at a Glance</h2>

  <p>The basic idea behind Hydra is to provide a vocabulary which enables a
    server to advertise valid state transitions to a client. A client can
    then use this information to construct HTTP requests which modify the
    server’s state so that a certain desired goal is achieved. Since all
    the information about the valid state transitions is exchanged in a
    machine-processable way at runtime instead of being hardcoded into the
    client at design time, clients can be decoupled from the server and
    adapt to changes more easily.</p>

  <p>The figure below illustrates the Hydra core vocabulary (the figure’s
    intention is to show how Hydra is used rather than its precise
    definition).</p>

  <p class="issue">Is this illustration clear enough or is it confusing?
    Feedback would be much appreciated.</p>

  <div class="illustration">
    <p><img src="vocabulary.png" alt="The Hydra core vocabulary" /></p>
    <p class="caption">The Hydra core vocabulary</p>
  </div>

  <p>An alphabetical index of the classes and properties of Hydra is
    given below. All the terms are hyperlinked to their detailed
    description for quick reference.</p>

  <p id="vocabulary-overview"></p>

  <p class="issue">The used prefixes should be documented somewhere.</p>
</section>

<section>
  <h2>Using Hydra</h2>

  <p>Throughout this section, a simple Web API featuring an issue tracker
    will be used to illustrate how Hydra can be used. The Web API enables
    its users to file new issues, modify or delete existing ones, and
    to comment them. For the sake of simplicity, orthogonal aspects such
    as authentication or authorization are not covered.</p>

  <section>
    <h3>Adding Affordances to Representations</h3>

    <p>The exemplary Web API has to expose representations of issues and
      comments. To enable interaction with those resources, a client has
      to know which operations the server supports. In human-facing
      websites such affordances are typically exposed by links and forms
      and described in natural language. Unfortunately, machines can not
      interpret such information easily. The solution that presents itself
      is to reduce the language to a small number of unambiguous concepts
      which are easily recognizable by a machine client. Hydra formalizes
      such concepts.</p>

    <p>The simplest and most important affordance on the Web are
      hyperlinks. Without them, it would be impossible to browse the Web.
      Users typically select the link based on the text it is labeled
      with. To give machines a similar understanding, links can be
      annotated with a link relation type&mdash;a registered token or a
      URI identifying the semantics of the link. The following example
      shows how such a typed link is used in HTML to reference a
      stylesheet.</p>

    <pre class="example" data-transform="updateExample"
         title="A typed link referencing a stylesheet as used in HTML">
      <!--
      <link ****rel="stylesheet"**** href="http://www.example.com/styles.css" />
      -->
    </pre>

    <p>In Linked Data, the link relation type corresponds to the property
      itself. An example in JSON-LD would thus look as follows.</p>

    <pre class="example" data-transform="updateExample"
         title="Referencing a stylesheet in JSON-LD">
      <!--
      {
        ****"urn:iana:link-relations:stylesheet"****: { "@id": "http://www.example.com/styles.css" }
      }
      -->
    </pre>

<!--     <p class="note">The <code>urn:iana:link-relations:stylesheet</code> URN
      is not officially registered (yet). For the moment, see
      <a href="http://tools.ietf.org/html/draft-saintandre-iana-urn">draft-saintandre-iana-urn</a>
      which defines this URN pattern.</p> -->

    <p>Generally, a client decides whether to follow a link or not based on
      the link relation (or the property in general, in the case of
      Linked Data) which defines its semantics. There are however also
      clients such as Web crawlers which simply follow every which is
      intended to be dereferenced. In HTML this usually means that all
      links in anchor elements (the <code>&lt;a&gt;</code> tag) are
      followed but, e.g., most references in link elements (the
      <code>&lt;link&gt;</code> tag), such as used in the example above,
      are ignored. Since in RDF serializations no such distinction exists,
      the best a client can do is to blindly try to dereference all URIs.
      It would thus be beneficial to describe in a machine-readable manner
      whether a property represents a link that is intended to be
      dereferenced or whether it solely represents an identifier. Hydra's
      <i>Link</i> class does just that. It can be used to define properties
      that represent dereferenceable links. In the exemplary Web API used
      throughout this section, it can, e.g., be used to define a property
      linking issues to their comments:</p>

    <pre class="example" data-transform="updateExample"
         title="Definining properties representing hyperlinks using Hydra's Link class">
      <!--
      {
        "@context": "http://purl.org/hydra/core/context.jsonld",
        "@id": "http://example.com/vocab#comments",
        ****"@type": "Link"****
      }
      -->
    </pre>

    <p>In the example above, a property identified with the URL
      <code>http://example.com/vocab#comments</code> is be defined to be
      of the type <i>Link</i>. This is enough information for a client
      understanding Hydra to know that the value of the
      <code>comments</code> property in the following example is intended
      to be dereferenced.</p>

    <pre class="example" data-transform="updateExample"
         title="Using a property defined to be a hyperlink">
      <!--
      {
        "@context": {
          ****"comments": "http://example.com/vocab#comments"****
        },
        "@id": "http://example.com/an-issue",
        "title": "An exemplary issue linking to its comments",
        ****"comments": { "@id": "http://example.com/an-issue/comments" }****
      }
      -->
    </pre>

    <p>In the example above, the value of the <code>comments</code>
      property is a JSON object with an <code>@id</code> member. This is
      JSON-LD's convention to distinguish between strings and IRIs. By
      using JSON-LD's type-coercion feature, the representation can be
      made even more idiomatic:</p>

    <pre class="example" data-transform="updateExample"
         title="Using JSON-LD's type-coercion feature to create idiomatic representations">
      <!--
      {
        "@context": {
          "comments": { "@id": "http://example.com/vocab#comments", ****"@type": "@id"**** }
        },
        "@id": "http://example.com/an-issue",
        "title": "An exemplary issue linking to its comments",
        "comments": ****"http://example.com/an-issue/comments"****
      }
      -->
    </pre>

    <p>While links are enough to build read-only Web APIs, more powerful
      affordances are required to build read-write Web APIs. Thus, Hydra
      introduces the notion of operations. Simply speaking, an
      <i>Operation</i> represents the information necessary for a client
      to construct valid HTTP requests in order to manipulate the server's
      resource state. As such, the only required property of an
      <i>Operation</i> is its HTTP <i>method</i>. Optionally, it is
      also possible to describe what information the server <i>expects</i>
      or <i>returns</i>, including additional information about HTTP
      status codes that might be returned. This helps a developer to
      understand what to expect when invoking an operation. This
      information has, however, not to be considered as being complete;
      it is merely a hint. Developers should, e.g., expect that other
      HTTP status codes might be returned and program their clients
      accordingly.</p>

    <p>Hydra has three predefined operation classes, namely
      <i>CreateResourceOperation</i>, <i>ReplaceResourceOperation</i>,
      and <i>DeleteResourceOperation</i>. As their names suggest, they
      can be used to implement simple
      <abbr title="Create, replace, update, and delete">CRUD</abbr>
      functionality. More specialized operations can be easily created
      by subclassing these classes or their base class <i>Operation</i>.</p>

    <p>The following example illustrates how representations can be
      augmented with information that enables clients to interact with
      them. A client would be able to understand that the resource in
      the example below can be deleted by sending an HTTP DELETE
      request.</p>

    <pre class="example" data-transform="updateExample"
         title="A representation of an issue augmented with a delete operation">
      <!--
      {
        ****"@context": "http://purl.org/hydra/core/context.jsonld"****,
        "@id": "/an-issue",
        "title": "An exemplary issue representation",
        "description": "This issue can be deleted with an HTTP DELETE request"
        ****"operations"****: [
          ****{
            "@type": "DeleteResourceOperation",
            "method": "DELETE"
          }****
        ]
      }
      -->
    </pre>

    <p>The example above references Hydra's context to map properties such
      as <code>operations</code> and <code>method</code> and values like
      <code>DeleteResourceOperation</code> to URLs that unambiguously
      identify these concepts. It would be similarly valid JSON-LD if
      these mappings would be directly embedded into the representation
      or if the full URLs would be used instead. Typically, however, the
      context is the same for a lot of representations in a Web API and
      it thus makes sense to reduce the response size by leveraging a
      remote context that can easily be cached by a client.</p>
  </section>

  <section>
    <h3>Documenting a Web API</h3>

    <p>In Web APIs, most representations are typically very similar.
      Furthermore, resources often support the same operations. It thus
      makes sense, to collect this information in a central documentation.
      Traditionally, this has been done in natural language which forces
      developers to hardcode that knowledge into their clients. Hydra
      addresses this issue by making the documentation completely
      machine-processable. The fact that all definitions can be identified
      by URLs enables reuse at unprecedented granularity.</p>

    <p>Hydra's <i>ApiDocumentation</i> class builds the foundation for
      the description of a Web API. As shown in the following example,
      Hydra describes a API by giving it a title, a short description, and
      documenting its main entry point. Furthermore, the classes known to
      be supported by the Web API and additional information about status
      codes that might be returned can be documented. This information
      may be used to automatically generate documentations in natural
      language.</p>

    <pre class="example" data-transform="updateExample"
         title="The overall structure of a Hydra API documentation">
      <!--
      {
        "@context": "http://purl.org/hydra/core/context.jsonld",
        "@id": "http://api.example.com/doc/",
        ****"@type": "ApiDocumentation"****,
        ****"title"****: ####"The name of the API",####
        ****"description"****: ####"A short description of the API",####
        ****"entrypoint"****: ####"URL of the API's main entry point",####
        ****"supportedClasses"****: [
          ####... The classes known to be supported by the Web API ...####
        ],
        ****"statusCodes"****: [
          ####... Additional information about HTTP status codes ... ####
        ]
      }
      -->
    </pre>

    <p>In Linked Data, properties are, just as everything else, identified
      by IRIs and thus have global scope which implies that they have
      independent semantics. In contrast, properties in data models as
      used in common programming languages are class-dependent. Their
      semantics depend on the class they belong to. In data models classes
      are typically described by the properties they expose whereas in
      Linked Data properties define to which classes they belong. If no
      class is specified, it is assumed that a property may apply to every
      class.</p>

    <p>These differences have interesting consequences. For example, the
      commonly asked question of which properties can be applied to an
      instance of a specific class can typically not be answered for
      Linked Data. Strictly speaking, any property which is not explicitly
      forbidden could be applied. This stems from the fact that Linked Data
      works under an open-world assumption whereas data models used by
      programmers typically work under a closed-world assumption. The
      difference is that when a closed world is assumed, everything that
      is not known to be true is false or vice-versa. With an open-world
      assumption the failure to derive a fact does not automatically imply
      the opposite; it embraces the fact that the knowledge is
      incomplete.</p>

    <p>Since Hydra uses classes to describe the information expected or
      returned by an operation, it also defines a concept to describe the
      properties known to be supported by a class. The following example
      illustrates this feature. Instead of referencing properties directly,
      <i>supportedProperties</i> references an intermediate data structure,
      namely instances of the <i>SupportedProperty</i> class. This makes
      it possible to define whether a specific property is required or
      whether it is read-only or write-only depending on the class it is
      associated with.</p>

    <pre class="example" data-transform="updateExample"
         title="Defining a class and documenting its supported properties">
      <!--
      {
        "@context": "http://purl.org/hydra/core/context.jsonld",
        "@id": "http://api.example.com/doc/#Comment",
        ****"@type": "Class"****,
        ****"title"****: ####"The name of the class",####
        ****"description"****: ####"A short description of the class.",####
        ****"supportedProperties"****: [
          ####... The properties known to be supported by the class ...####
          {
            ****"@type": "SupportedProperty"****,
            ****"property"****: ####The property####,
            ****"required"****: ####Is the property required in a request to be valid####
            ****"readonly"****: ####Can the property's value be modified?####
            ****"writeonly"****: ####Is the property's value included in responses?####
          }
        ]
      }
      -->
    </pre>

    <p>All instances of a specific class typically support the same
      operations. Hydra therefore features a <i>supportedOperations</i>
      property which defines the operations supported by all instances of
      a class.</p>

    <pre class="example" data-transform="updateExample"
         title="Defining a class and documenting its supported operations">
      <!--
      {
        "@context": "http://purl.org/hydra/core/context.jsonld",
        "@id": "http://api.example.com/doc/#Comment",
        "@type": "Class",
        "title": ####"The name of the class",####
        "description": ####"A short description of the class.",####
        "supportedProperties": [
          ####... The properties known to be supported by the class ...####
        ],
        ****"supportedOperations"****: [
          ####... The operations known to be supported by instances of the class ...####
        ]
      }
      -->
    </pre>

    <p>The same feature can be used to describe the operations supported
      by values of a <i>Link</i> property. This is often helpful when
      certain operations depend on the permissions of the current user. It
      makes it, e.g., possible to show a "delete" link only if the current
      user has the permission to delete the resource. Otherwise, the link
      would simply be hidden in the representation.</p>

    <pre class="example" data-transform="updateExample"
         title="Documenting the supported operations of link properties">
      <!--
      {
        "@context": "http://purl.org/hydra/core/context.jsonld",
        "@id": "http://api.example.com/doc/#comments",
        ****"@type": "Link"****,
        "title": "Comments",
        "description": "A link to comments with an operation to create a new comment.",
        ****"supportedOperations"****: [
          ****{
            "@type": "CreateResourceOperation",
            "title": "Creates a new comment",
            "method": "POST",
            "expects": "http://api.example.com/doc/#Comment",
            "returns": "http://api.example.com/doc/#Comment",
            "statusCodes": ####... optional information about status codes that might be returned ...####
          }****
        ]
      }
      -->
    </pre>
  </section>

  <section>
    <h3>Discovering a Hydra-powered Web API</h3>

    <p>The first step when trying to access a Web API is to find an entry
      point. Typically, this is done by looking for documentation on the
      API publisher's homepage. Hydra enables the API's main entry point
      to be discovered automatically if the API publisher marks his
      responses with a special HTTP Link Header as defined in [[RFC5988]].
      A Hydra client would look a Link Header with a relation type
      <code>http://purl.org/hydra/core#apiDocumentation</code> (this is
      the IRI identifying the <i>hydra:apiDocumentation</i> property).</p>

    <p>In the following example, a Hydra client simply accesses the
      homepage of an API publisher (<code>http://www.example.com</code>)
      to find the entry point of its API. A client may use an HTTP GET or
      HEAD request. The difference between the two is that the former may
      return a message-body in the response whereas the latter will not;
      otherwise they are identical.</p>

    <pre class="example" data-transform="updateExample"
         title="Discovering Hydra API documentation documents">
      <!--
      HEAD / HTTP/1.1
      Host: www.example.com

      ====================================

      HTTP/1.1 200 OK
      ...
      Content-Type: application/ld+json
      ****Link: <http://api.example.com/doc/>; rel="http://purl.org/hydra/core#apiDocumentation"****
      -->
    </pre>

    <p>The response in the example above contains an HTTP Link Header
      pointing to <code>http://api.example.com/doc/</code>.
      Retrieving that resource, the client would obtain a
      <a>Hydra API documentation</a> defining the API's main entry
      point:</p>

    <pre class="example" data-transform="updateExample"
         title="Retrieving a Hydra API documentation to obtain the main entry point">
      <!--
      GET /doc/ HTTP/1.1
      Host: api.example.com
      Accept: application/ld+json,application/json,*/*;q=0.1

      ====================================

      HTTP/1.1 200 OK
      ...
      Content-Type: application/ld+json

      {
        "@context": "http://purl.org/hydra/core/context.jsonld",
        "@id": "http://api.example.com/api/doc/",
        "title": "The example.com API",
        ****"entrypoint": "http://api.example.com/"****,
        ...
      }
      -->
    </pre>

    <p>Please note that in most cases the entry point will already be
      known to the client. Thus, the discovery of the API documentation
      using HTTP Link Headers is typically not necessary as the concepts
      used in responses from the API will dereference to their
      documentation.</p>
  </section>
</section>

<section>
  <h2>Advanced Concepts</h2>

  <p class="issue">Describe TemplatedLink (IriTemplate, IriTemplateMapping),
    Error, and Resource.</p>

  <section>
    <h3>Collections</h3>

    <p>In many situations, it makes sense to expose resources that reference
      a set of somehow related resources. Results of a search query or
      entries of an address book are just two examples. To simplify such
      use cases, Hydra defines the two classes <i>hydra:Collection</i> and
      <i>hydra:PagedCollection</i>.</p>

    <p>A <i>hydra:Collection</i> can be used to reference a set of resources
      as follows:</p>

    <pre class="example" data-transform="updateExample"
         title="Referencing related resources using a Hydra Collection">
      <!--
      {
        "@context": "http://purl.org/hydra/core/context.jsonld",
        "@id": "http://api.example.com/posts/1/comments",
        ****"@type": "Collection"****,
        ****"members"****: [
          {
            "@id": "/comments/429"
          },
          {
            "@id": "/comments/781",
            "title": "Properties may be embedded directly in the collection"
          },
          ...
        ]
      }
      -->
    </pre>

    <p>As shown in the example above, member items can either consist of
      solely a link or also include some properties. In some cases embedding
      member properties directly in the collection is beneficial as it may
      reduce the number of HTTP requests necessary to get enough information
      to process the result.</p>

    <p>Since collections may become very large, Web APIs often chose to
      split a collection into multiple pages. In Hydra, that can be achieved
      with a <i>hydra:PagedCollection</i>. Additionally to the
      <i>members</i> property, a <i>PagedCollection</i> may also include
      links to the <i>firstPage</i>, <i>nextPage</i>, <i>previousPage</i>,
      or <i>lastPage</i> as well as information about the
      <i>itemsPerPage</i> and the <i>totalItems</i> as shown in the
      following example.</p>

    <pre class="example" data-transform="updateExample"
         title="A Hydra PagedCollection splites a collection into multiple pages">
      <!--
      {
        "@context": "http://purl.org/hydra/core/context.jsonld",
        "@id": "http://api.example.com/posts/1/comments?page=3",
        ****"@type": "PagedCollection"****,
        ****"totalItems": "4980"****,
        ****"itemsPerPage": "10"****,
        ****"firstPage": "/posts/1/comments?page=1"****,
        ****"nextPage": "/posts/1/comments?page=4"****,
        ****"previousPage": "/posts/1/comments?page=2"****,
        ****"lastPage": "/posts/1/comments?page=498"****,
        "members": [
          ####... the members of this PagedCollection ...####
        ]
      }
      -->
    </pre>

    <p class="issue">Say that all these properties are optional? What about
      <i>firstPage</i> and, more interestingly, <i>lastPage</i>?</p>

  </section>

<!--   <section>
    <h3>Using Hydra Descriptions as JSON</h3>

    <p class="issue">The are multiple ways to serialize a
      <a>Hydra API documentation</a> in JSON-LD. To make it usable also for
      plain-old JSON clients, the serialization has to have a deterministic
      shape. The definition of a profile will make it possible to signal
      or request specific serialization conventions at the media type
      level. The definition of the profile might be as simple as defining
      a JSON-LD frame.</p>
  </section> -->
</section>

<section>
  <h2>Classes</h2>

  <div id="vocabulary-classes"></div>
</section>

<section>
  <h2>Properties</h2>

  <div id="vocabulary-properties"></div>
</section>

<section class="appendix informative">
  <h2>The Hydra Core Vocabulary in JSON-LD</h2>

  <pre id="vocabulary-jsonld">
  </pre>
</section>

</body>
</html>
