<!DOCTYPE html>
<html>
<head>
<title>Hydra Core Vocabulary</title>
<meta charset="utf-8">
<script type="text/javascript" src="https://www.w3.org/Tools/respec/respec-w3c-common" async class="remove"></script>
<script type="text/javascript" src="../../js/jsonld.js" class="remove"></script>
<script type="text/javascript" src="../../js/respec-w3c-extensions.js" class="remove"></script>
<script type="text/javascript" class="remove">
//<![CDATA[
  var respecConfig = {
      // extend the bibliography entries
      localBiblio: localBibliography,

      // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
      specStatus: "unofficial",

      //publishDate: "2012-08-30",

      copyrightStart: "2012",
      additionalCopyrightHolders: 'Copyright © 2012-' + new Date().getFullYear() + ' the Contributors to the Hydra Core Vocabulary Specification, published by the <a href="http://www.w3.org/community/hydra/">Hydra W3C Community Group</a> under the <a href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>. A human-readable <a href="http://www.w3.org/community/about/agreements/cla-deed/">summary</a> is available.',

      // the specification's short name, as in http://www.w3.org/TR/short-name/
      shortName: "hydra",
      subtitle: "A Vocabulary for Hypermedia-Driven Web APIs",

      // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
      // and its maturity status
      // previousPublishDate: "2012-08-30",
      // previousMaturity: "FPWD",
      // previousDiffURI: "http://www.w3.org/TR/2012/WD-json-ld-syntax-20120830/",
      // diffTool: "http://www.aptest.com/standards/htmldiff/htmldiff.pl",

      // if there a publicly available Editor's Draft, this is the link
      edDraftURI: "http://www.hydra-cg.com/spec/latest/core/",

      // if this is a LCWD, uncomment and set the end of its review period
      // lcEnd: "2009-08-05",

      issueBase: "https://github.com/lanthaler/hydra/issues/",

      // if you want to have extra CSS, append them to this list
      // it is recommended that the respec.css stylesheet be kept
      // extraCSS:             [],

      // editors, add as many as you like
      // only "name" is required
      editors:  [
          {
            name: "Markus Lanthaler",
            url: "http://www.markus-lanthaler.com/",
            company: "Google",
            w3cid: 49179
          }
      ],

      // authors, add as many as you like.
      // This is optional, uncomment if you have authors as well as editors.
      // only "name" is required. Same format as editors.
      authors:  [
          { name: "Markus Lanthaler", url: "http://www.markus-lanthaler.com/",
            company: "Google" }
      ],

      // WG information
      wg:           "Hydra W3C Community Group",
      wgURI:        "http://www.hydra-cg.com/",
      wgPublicList: "public-hydra",
      // wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/??????/status",

      maxTocLevel: 4,
      postProcess: [ postProc ],
      alternateFormats: [
          // { uri: "diff-20120712.html", label: "diff to previous version" }
          { uri: "core.jsonld", label: "JSON-LD" },
          { uri: "core.ttl", label: "Turtle" },
      ]
  };
//]]>
</script>
<style type="text/css">
  html {
    background-image: none !important;
  }
  .hlist {
    border: 1px solid navy;
    padding:5px;
    background-color: #F4FFFF;
  }
  .hlist li {
    display: inline;
    display: inline-table;
    list-style-type: none;
    padding-right: 20px;
  }
  .highlight {
    font-weight: bold;
    color: #0a3;
  }
  .comment {
    color: #999;
  }
  .illustration {
    text-align: center;
  }
  #vocabulary-jsonld {
    white-space: pre-wrap;
  }
</style>
</head>

<body>
<section id="abstract">
  <p>Hydra is a lightweight vocabulary to create hypermedia-driven Web APIs.
    By specifying a number of concepts commonly used in Web APIs it enables
    the creation of generic API clients.</p>
</section>

<section id="sotd">
  <p class="issue">This entire document is a work in progress and several
    sections are incomplete, missing, or outdated. All open issues and decisions
    are documented in our
    <a href="https://github.com/HydraCG/Specifications/issues">issue tracker</a>.
    If you have questions, please don't hesitate to
    <a href="http://www.hydra-cg.com/#community">join the Hydra W3C Community Group and post to the mailing list.</a>
  </p>

  <p>This specification was published by the
    <a href="http://www.w3.org/community/hydra/">Hydra W3C Community Group</a>. It is
    not a W3C Standard nor is it on the W3C Standards Track. Please note that under the
    <a href="http://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>
    there is a limited opt-out and other conditions apply. Learn more about
    <a href="http://www.w3.org/community/">W3C Community and Business Groups</a>.</p>

  <p>To participate in the development of this specification, please join the
    <a href="http://www.w3.org/community/hydra/">Hydra W3C Community Group</a>. If
    you have questions, want to suggest a feature, or raise an issue, please send a mail to the
    <a href="http://lists.w3.org/Archives/Public/public-hydra/">public-hydra@w3.org mailing list</a>.</p>
</section>

<section class="informative">
  <h2>Introduction</h2>

  <p>Coping with the ever-increasing amount of data becomes
    increasingly challenging. To alleviate the information overload put on
    people, systems are progressively being connected directly to each
    other. They exchange, analyze, and manipulate humongous amounts of
    data without any human interaction. Most current solutions, however,
    do not exploit the whole potential of the architecture of the World
    Wide Web and completely ignore the possibilities offered by Linked Data
    technologies.</p>

  <p>The combination of the REST architectural style and the Linked
    Data principles offer opportunities to advance the Web of machines
    in a similar way that hypertext did for the human Web. Most
    building blocks exist already and are in place but they are rarely
    used together. Hydra tries to fill that gap. It allows data to be
    enriched with machine-readable affordances which enable
    interaction. This not only addresses the problem that Linked Data
    is still mostly read-only, but it also paves the way for a
    completely new breed of interoperable Web APIs. The fact that it
    enables the creation of composable contracts means that
    interaction models of Web APIs can be reused at an unprecedented
    granularity.</p>
</section>

<section>
  <h2>Conformance</h2>

  <p>This specification describes the conformance criteria for
    <dfn data-lt="Hydra API documentation">Hydra API documentations</dfn>
    and <dfn data-lt="Hydra client">Hydra clients</dfn>. These criteria are
    relevant to authors, authoring tool implementers, and client
    implementers. All authoring guidelines, diagrams, examples, and notes
    in this specification are non-normative, as are all sections
    explicitly marked as non-normative. Everything else in this
    specification is normative.</p>

  <p class="issue">Conformance for Hydra clients should probably not be
    specified in this document.</p>

  <p class="issue">Add normative statements</p>

  <p>The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
    SHOULD NOT, RECOMMENDED, NOT RECOMMENDED, MAY, and OPTIONAL in this
    specification have the meaning defined in [[!RFC2119]].</p>
</section>

<section class="informative">
  <h2>Hydra at a Glance</h2>

  <p>The basic idea behind Hydra is to provide a vocabulary which enables a
    server to advertise valid state transitions to a client. A client can
    then use this information to construct HTTP requests which modify the
    server’s state so that a certain desired goal is achieved. Since all
    the information about the valid state transitions is exchanged in a
    machine-processable way at runtime instead of being hardcoded into the
    client at design time, clients can be decoupled from the server and
    adapt to changes more easily.</p>

  <p>The namespace of the Hydra core vocabulary is
    <code>http://www.w3.org/ns/hydra/core#</code>, and the suggested prefix
    is <code>hydra</code>. The figure below illustrates the vocabulary (the
    figure’s goal is to show how Hydra is used rather than its precise
    definition).</p>

  <p class="issue">Is this illustration clear enough or is it confusing?
    Feedback would be much appreciated.</p>

  <div class="illustration">
    <p><img src="vocabulary.png" alt="The Hydra core vocabulary" /></p>
    <p class="caption">The Hydra core vocabulary</p>
  </div>

  <p class="issue">Add ranges for Operation "members"</p>

  <p>An alphabetical index of the classes and properties of Hydra is
    given below. All the terms are hyperlinked to their detailed
    description for quick reference.</p>

  <p id="vocabulary-overview"></p>

  <p class="issue">The used prefixes should be documented somewhere.</p>
</section>

<section>
  <h2>Using Hydra</h2>

  <p>Throughout this section, a simple Web API featuring an issue tracker
    will be used to illustrate how Hydra can be used. The Web API enables
    its users to file new issues, modify or delete existing ones, and
    to comment them. For the sake of simplicity, orthogonal aspects such
    as authentication or authorization are not covered.</p>

  <section>
    <h3>Adding Affordances to Representations</h3>

    <p>The exemplary Web API has to expose representations of issues and
      comments. To enable interaction with those resources, a client has
      to know which operations the server supports. In human-facing
      websites such affordances are typically exposed by links and forms
      and described in natural language. Unfortunately, machines can not
      interpret such information easily. The solution that presents itself
      is to reduce the language to a small number of unambiguous concepts
      which are easily recognizable by a machine client. Hydra formalizes
      such concepts.</p>

    <p>The simplest and most important affordance on the Web are
      hyperlinks. Without them, it would be impossible to browse the Web.
      Users typically select the link based on the text it is labeled
      with. To give machines a similar understanding, links can be
      annotated with a link relation type&mdash;a registered token or a
      URI identifying the semantics of the link. The following example
      shows how such a typed link is used in HTML to reference a
      stylesheet.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="A typed link referencing a stylesheet as used in HTML">
      <!--
      <link ****rel="stylesheet"**** href="http://www.example.com/styles.css" />
      -->
    </pre>

    <p>In Linked Data, the link relation type corresponds to the property
      itself. An example in JSON-LD would thus look as follows.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Referencing a stylesheet in JSON-LD">
      <!--
      {
        ****"urn:iana:link-relations:stylesheet"****: { "@id": "http://www.example.com/styles.css" }
      }
      -->
    </pre>

<!--     <p class="note">The <code>urn:iana:link-relations:stylesheet</code> URN
      is not officially registered (yet). For the moment, see
      <a href="http://tools.ietf.org/html/draft-saintandre-iana-urn">draft-saintandre-iana-urn</a>
      which defines this URN pattern.</p> -->

    <p>Generally, a client decides whether to follow a link or not based on
      the link relation (or property in the case of
      Linked Data) which defines its semantics. There are however also
      clients such as Web crawlers which simply follow every link
      intended to be dereferenced. In HTML this usually means that all
      links in anchor elements (the <code>&lt;a&gt;</code> tag) are
      followed but most references in link elements (the
      <code>&lt;link&gt;</code> tag), such as used in the example above,
      are ignored. Since in RDF serializations no such distinction exists,
      the best a client can do is to blindly try to dereference all URIs.
      It would thus be beneficial to describe in a machine-readable manner
      if a property represents a link intended to be
      dereferenced or solely an identifier. Hydra's
      <i>Link</i> class does just that. It can be used to define properties
      that represent dereferenceable links. In the exemplary Web API used
      throughout this section, it can be used to define a property
      linking issues to their comments:</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Defining properties representing hyperlinks using Hydra's Link class">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/vocab#comments",
        ****"@type": "Link"****
      }
      -->
    </pre>

    <p>In the example above, a property identified with the URL
      <code>http://api.example.com/vocab#comments</code> is defined to be
      of the type <i>Link</i>. This is enough information for a client
      understanding Hydra to know that the value of the
      <code>comments</code> property in the following example is intended
      to be dereferenced.</p>

    <p class="note">It is recommended to dereference resources that are
      within an API's domain. This may prevent possible issues with cross-site
      scripting or obtaining resources which might have no meaning
      to the client or such that the client would be unable to interpret.
      Still, there is no formal prohibition of dereferencing resources
      linked with well-known properties, e.g. <i>rdf:seeAlso</i>.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Using a property defined to be a hyperlink">
      <!--
      {
        "@context": {
          ****"comments": "http://api.example.com/vocab#comments"****
        },
        "@id": "http://api.example.com/an-issue",
        "title": "An exemplary issue linking to its comments",
        ****"comments": { "@id": "http://api.example.com/an-issue/comments" }****
      }
      -->
    </pre>

    <p>In the example above, the value of the <code>comments</code>
      property is a JSON object with an <code>@id</code> member. This is
      JSON-LD's convention to distinguish between strings and IRIs. By
      using JSON-LD's type-coercion feature, the representation can be
      made even more idiomatic:</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Using JSON-LD's type-coercion feature to create idiomatic representations">
      <!--
      {
        "@context": {
          "comments": { "@id": "http://api.example.com/vocab#comments", ****"@type": "@id"**** }
        },
        "@id": "http://api.example.com/an-issue",
        "title": "An exemplary issue linking to its comments",
        "comments": ****"http://api.example.com/an-issue/comments"****
      }
      -->
    </pre>

    <p>While links are enough to build read-only Web APIs, more powerful
      affordances are required to build read-write Web APIs. Thus, Hydra
      introduces the notion of operations. Simply speaking, an
      <i>Operation</i> represents the information necessary for a client
      to construct valid HTTP requests in order to manipulate the server's
      resource state. As such, the only required property of an
      <i>Operation</i> is its HTTP <i>method</i>. Optionally, it is
      also possible to describe what information the server <i>expects</i>
      or <i>returns</i>, including additional information about HTTP
      status codes that might be returned. This helps a developer to
      understand what to expect when invoking an operation. This
      information has, however, not to be considered as being complete;
      it is merely a hint. Developers should, e.g., expect that other
      HTTP status codes might be returned and program their clients
      accordingly.</p>

    <p>The following example illustrates how representations can be
      augmented with information that enables clients to interact with
      them.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="A representation of an issue augmented with a delete operation">
      <!--
      {
        ****"@context": "http://www.w3.org/ns/hydra/context.jsonld"****,
        "@id": "/an-issue",
        "title": "An exemplary issue representation",
        "description": "This issue can be deleted with an HTTP DELETE request",
        ****"operation"****: [
          ****{
            "@type": "Operation",
            "method": "DELETE"
          }****
        ]
      }
      -->
    </pre>

    <p>The example above references Hydra's context to map properties such
      as <code>operation</code> and <code>method</code> and values like
      <code>Operation</code> to URLs that unambiguously
      identify these concepts. It would be similarly valid JSON-LD if
      these mappings would be directly embedded into the representation
      or if the full URLs would be used instead. Typically, however, the
      context is the same for a lot of representations in a Web API and
      it thus makes sense to reduce the response size by leveraging a
      remote context that can easily be cached by a client.</p>

    <p>It is worth mentioning that due to the fact that Hydra is built on
      RDF, which is a graph, it may happen that a related resource
      (an object of the relation) may not be fully described in the
      resource's payload. In several circumstances (i.e. payload terms
      defined in <i>API documentation</i> sa described in
      <a href="#documenting-a-web-api">Documenting a Web API</a>
      or <i>IriTemplate</i> expected as a related resource as described in
      <a href="#templated-links">Templated Links</a>) client may
      discover no additional statements describing it. These rules should
      be considered by the client in following scenarios:
    </p>

    <ul>
      <li>in case of an object expected to be a hypermedia resource does not have all
        the necessary statements for which it is a subject, the client SHOULD look in the
        <i>API documentation</i> for more details</li>
      <li>in case the mentioned object, after consulting an <i>API documentation</i>, still
        does not have all the necessary statements for which it is a subject and both
        mentioned object's Url and Url of the initially obtained resource has the
        same scheme and authority (by means of [[!RFC3986]] sections 3.1 and 3.2), the client
        SHOULD de-reference that Url. If the resource does not have the same scheme and
        authority the client MAY choose to de-reference it (for example if the resource
        originates from another API well-known to the client)</li>
      <li>in case the mentioned object still does not have all the necessary
        statements for which it is a subject (i.e. de-referencing it failed
        or statements are missing), the client SHOULD either ignore the whole
        statement (i.e. for display purposes) or throw an exception (i.e. an
        <i>IriTemplate</i> is about to be resolved and de-referenced)</li>
    </ul>

    <p>Example of each of the situations are as follows:</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="IriTemplate details extraction">
      <!--
      HTTP/1.1 200 OK
      Content-Type: application/ld+json
      Link: <http://api.example.com/doc/>; rel="http://www.w3.org/ns/hydra/core#apiDocumentation"

      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@graph": [{
          "@id": "http://api.example.com/people",
          "@type": "hydra:Collection",
          "api:personByName": "api:PersonByNameTemplate"
        }, {
          "@id": "http://api.example.com/events",
          "@type": "hydra:Collection",
          "api:eventByName": "api:EventByNameTemplate"
        }
      }

      HTTP/1.1 200 OK
      Content-Type: application/ld+json

      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@graph": [{
          "@id": "api:PersonByNameTemplate",
          "@type": "hydra:IriTemplate",
          "template": "http://api.example.com/people/{name}",
          ...
        }]
      }
      -->
    </pre>

    <p>where</p>

    <ul>
      <li>resource <i>http://api.example.com/people</i> should have an <i>IriTemplate</i> available
        as there is a complete definition of the template available at <i>http://api.example.com/doc/</i>.</li>
      <li>resource <i>http://api.example.com/events</i> should not have an Iri template exposed as there
        are no additional details available, neither in the initial resources' payload nor in the API documentation.</li>
    </ul>

    <p>Keep in mind that any resource described by any hypermedia control
      may fail at runtime due to various reasons. Operation details
      such as <i>returns</i> or <i>possibleStatus</i> may also vary at runtime,
      which means client SHOULD always verify received payloads at runtime.
      </p>
  </section>

  <section>
    <h3>Documenting a Web API</h3>

    <p>In Web APIs, most representations are typically very similar.
      Furthermore, resources often support the same operations. It thus
      makes sense, to collect this information in a central documentation.
      Traditionally, this has been done in natural language which forces
      developers to hardcode that knowledge into their clients. Hydra
      addresses this issue by making the documentation completely
      machine-processable. The fact that all definitions can be identified
      by URLs enables reuse at unprecedented granularity.</p>

    <p>Hydra's <i>ApiDocumentation</i> class builds the foundation for
      the description of a Web API. As shown in the following example,
      Hydra describes a API by giving it a title, a short description, and
      documenting its main entry point. Furthermore, the classes known to
      be supported by the Web API and additional information about status
      codes that might be returned can be documented. This information
      may be used to automatically generate documentations in natural
      language.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="The overall structure of a Hydra API documentation">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/doc/",
        ****"@type": "ApiDocumentation"****,
        ****"title"****: ####"The name of the API"####,
        ****"description"****: ####"A short description of the API"####,
        ****"entrypoint"****: ####"URL of the API's main entry point"####,
        ****"supportedClass"****: [
          ####... Classes known to be supported by the Web API ...####
        ],
        ****"possibleStatus"****: [
          ####... Statuses that should be expected and handled properly ... ####
        ]
      }
      -->
    </pre>

    <p>In Linked Data, properties are, just as everything else, identified
      by IRIs and thus have global scope which implies that they have
      independent semantics. In contrast, properties in data models as
      used in common programming languages are class-dependent. Their
      semantics depend on the class they belong to. In data models classes
      are typically described by the properties they expose whereas in
      Linked Data properties define to which classes they belong. If no
      class is specified, it is assumed that a property may apply to every
      class.</p>

    <p>These differences have interesting consequences. For example, the
      commonly asked question of which properties can be applied to an
      instance of a specific class can typically not be answered for
      Linked Data. Strictly speaking, any property which is not explicitly
      forbidden could be applied. This stems from the fact that Linked Data
      works under an open-world assumption whereas data models used by
      programmers typically work under a closed-world assumption. The
      difference is that when a closed world is assumed, everything that
      is not known to be true is false or vice-versa. With an open-world
      assumption the failure to derive a fact does not automatically imply
      the opposite; it embraces the fact that the knowledge is
      incomplete.</p>

    <p class="issue">Mention that Hydra classes are dereferenceable
      resources.</p>

    <p>Since Hydra uses classes to describe the information expected or
      returned by an operation, it also defines a concept to describe the
      properties known to be supported by a class. The following example
      illustrates this feature. Instead of referencing properties directly,
      <i>supportedProperty</i> references an intermediate data structure,
      namely instances of the <i>SupportedProperty</i> class. This makes
      it possible to define whether a specific property is required or
      whether it is read-only or write-only depending on the class it is
      associated with.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Defining a class and documenting its supported properties">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/doc/#Comment",
        ****"@type": "Class"****,
        ****"title"****: ####"The name of the class"####,
        ****"description"****: ####"A short description of the class."####,
        ****"supportedProperty"****: [
          ####... Properties known to be supported by the class ...####
          {
            ****"@type": "SupportedProperty"****,
            ****"property"****: "#property", ####// The property####
            ****"required"****: true, ####// Is the property required in a request to be valid?####
            ****"readable"****: false, ####// Can the client retrieve the property's value?####
            ****"writable"****: true ####// Can the client change the property's value?####
          }
        ]
      }
      -->
    </pre>

    <p>All instances of a specific class typically support the same
      operations. Hydra therefore features a <i>supportedOperation</i>
      property which defines the operations supported by all instances of
      a class.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Defining a class and documenting its supported operations">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/doc/#Comment",
        "@type": "Class",
        "title": ####"The name of the class"####,
        "description": ####"A short description of the class."####,
        "supportedProperty": [
          ####... Properties known to be supported by the class ...####
        ],
        ****"supportedOperation"****: [
          ####... Operations known to be supported by instances of the class ...####
        ]
      }
      -->
    </pre>

    <p>The same feature can be used to describe the operations supported
      by values of a <i>Link</i> property. This is often helpful when
      certain operations depend on the permissions of the current user. It
      makes it, e.g., possible to show a "delete" link only if the current
      user has the permission to delete the resource. Otherwise, the link
      would simply be hidden in the representation.</p>

    <p>Example shown below describes the operation's expected and returned
      value as a dereferencable resource (an RDF resource of a given class),
      but the vocabulary is not limited to only those originating
      from RDF and is enabled to other types of resources.
      Please note that in case of multiple either returned or expected types
      provided, client SHOULD assume the set includes any of the types,
      but not limited to those types and client SHOULD interpret received
      payload at runtime for possible discrepancies.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Documenting the supported operations of link properties">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/doc/#comments",
        ****"@type": "Link"****,
        "title": "Comments",
        "description": "A link to comments with an operation to create a new comment.",
        ****"supportedOperation"****: [
          ****{
            "@type": "Operation",
            "title": "Creates a new comment",
            "method": "POST",
            "expects": "http://api.example.com/doc/#Comment",
            "returns": "http://api.example.com/doc/#Comment",
            "possibleStatus": [****
              ####... Statuses that should be expected and handled properly ...####
            ****]
          }****
        ]
      }
      -->
    </pre>

    <p>In addition to expected/returned resources, it is also possible to
      express similar features for headers with <i>returnsHeader</i> and
      <i>expectsHeader</i> predicates which provides a simple set of header
      names. Client SHOULD apply respective header semantics when creating
      or receiving a request natural for the protocol in use.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Making a use of a returned header">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/doc/#comments",
        "@type": "Link",
        "supportedOperation": [
          {
            "@type": "Operation",
            "method": "POST",
            "expects": "http://api.example.com/doc/#Comment",
            "returns": "http://api.example.com/doc/#Comment",
            ****"returnsHeader"****: [
              "Content-Type",
              "Content-Length"],
            ****"expectsHeader"****: [
              "Authorization"
            ]
          }
        ]
      }
      -->
    </pre>

    <p>The example above enable an HTTP client to prepare a proper cross-site
      pre-flight request so the server exposes enlisted headers for the client.
      The client is also aware of the user authentication requirement necessary
      for the operation invocation.</p>

    <p>For more complex scenarios it is also possible to expand selected header
      specification with both name and possible values, i.e. when defining
      expected <i>Content-Type</i> values of resources that can be uploaded.
      In case multiple possible values are provided, client SHOULD assume
      that the set includes any of the values, but not limited to those values.
      In order to change that default behavior it is possible to use <i>closedSet</i>
      predicate on the header specification indicating that the set of provided
      values is, well, closed and no other values are available. In both case the client
      SHOULD interpret received payload at runtime for possible discrepancies. </p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Making a use of a expected header values">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/doc/#comments",
        "@type": "Link",
        "supportedOperation": [
          {
            "@type": "Operation",
            "method": "POST",
            "expects": "http://api.example.com/doc/#Upload",
            "returns": "http://api.example.com/doc/#Comment",
            ****"returnsHeader"****: [
              { "headerName": "Content-Type", "possibleValue": ["text/turtle", "application/ld+json"] }
              "Content-Length"],
            ****"expectsHeader"****: [
              "Authorization",
              { "headerName": "Content-Type", "possibleValue": ["image/gif", "image/png"] }]
          }
        ]
      }
      -->
    </pre>

    <p>To wrap up everything altogether, it is also possible to attach atomic
      operations supported by, well, supported property itself. This might
      come in handy for scenarios, when resource can be partially modified.
      It can be achieved with two approaches, both having advantages and
      disadvantages.</p>

    <p>First approach would involve adding a <i>supportedOperation</i> to the
      intermediate structure of <i>SupportedProperty</i>.
      This way prevents from leaking API specific features from the API itself
      to i.e. externally defined properties. Data aggregators won't assume that
      each instance with a given property could have such an operation.</p>

    <p>Another approach would require the API to elevate a specific property
      to <i>Link</i>, which can accept a <i>supportedOperation</i>. This
      is more intuitive in APIs operating with internally used vocabularies
      where assumption that every instance with that very specific property
      has the operation attached available.</p>

    <p>Direct usage of <i>supportedOperation</i> on <i>rdf:Property</i>
      without elevating it to the <i>Link</i> SHOULD NOT be implemented as clients
      may not discover such a construct correctly.</p>

    <p>These are the simple example scenarios and possible usages are not
      limited to those described above.</p>

    <p>Due to the fact an <i>ApiDocumentation</i> as all other resources may fail
      at runtime, it is important to take countermeasures.
      A simple strategy to try to recover from such a situation would be to reload
      the <i>ApiDocumentation</i> and redo all pre-computations that were
      based on the <i>ApiDocumentation</i> (or at least those that lead
      to the current failure). Another, simpler approach would require
      an application to show an error message with option to return
      to a previous or home screen.</p>

    <p class="issue">Describe the various properties of an operation.</p>

    <p>Hydra also allows enriching both <i>ApiDocumentation</i> and
      hypermedia controls with human-readable descriptions by applying
      <i>title</i> and <i>description</i> (as shown in the examples above).
      The former states a name of such a decorated element that could
      be displayed as a label. The latter provides its description
      to be presented i.e. as a hint.</p>

    <p>Aforementioned <i>title</i> and <i>description</i> SHOULD take precedence
      over standard <i>rdfs:label</i> and <i>rdfs:comment</i>.</p>

    <p>There is one more feature related to how Linked Data works. Consider the
      example below written in turtle syntax:</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="RDF as a graph">
      <!--
      # An example API documentation itself with all the standard bits
      @base <http://some.app/> .
      @prefix api: <http://some.api/> .
      @prefix ex: <http://ontology.example/> .
      @prefix hydra: <http://www.w3.org/ns/hydra/core#> .
      @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .

      <api>
        a hydra:ApiDocumentation ;
        hydra:supportedClass api:ClassOne, api:ClassTwo .

      # Anything else
      ex:SomeType a rdfs:Class .
      -->
    </pre>

    <p>and how it could be transformed with JSON-LD framing process:</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="RDF as a graph continued">
      <!--
      {
        "@context": {  },
        "@graph": [
          {
            "@id": "http://some.app/api",
            "@type": "hydra:ApiDocumentation",
            "hydra:supportedClass": [
              {
                "@id": "api:ClassTwo"
              },
              {
                "@id": "api:ClassOne"
              }
            ]
          }
        ]
      }
      -->
    </pre>

    <p>As you can see, additional details about <i>ex:SomeType</i> went
      missing, while this shouldn't happen. The fact that the IRI mentioned
      is an <i>rdfs:Class</i> may be meaningful for a correct interpretation
      of the received payload and this is a sole reason of why a Client
      SHOULD NOT disregard other parts of the payload that are not directly
      related to the API documentation or other hypermedia controls.</p>
  </section>

  <section>
    <h3>Discovering a Hydra-powered Web API</h3>

    <p>The first step when trying to access a Web API is to find an entry
      point. Typically, this is done by looking for documentation on the
      API publisher's homepage. Hydra enables the API's main entry point
      to be discovered automatically if the API publisher marks his
      responses with a special HTTP Link Header as defined in [[RFC5988]].
      A Hydra client would look for a Link Header with a relation type
      <code>http://www.w3.org/ns/hydra/core#apiDocumentation</code> (this is
      the IRI identifying the <i>hydra:apiDocumentation</i> property).</p>

    <p>In the following example, a Hydra client simply accesses the
      homepage of an API publisher (<code>http://www.example.com</code>)
      to find the entry point of its API. A client may use an HTTP GET or
      HEAD request. The difference between the two is that the former may
      return a message-body in the response whereas the latter will not;
      otherwise they are identical.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Discovering Hydra API documentation documents">
      <!--
      HEAD / HTTP/1.1
      Host: www.example.com

      ====================================

      HTTP/1.1 200 OK
      ...
      Content-Type: text/html; charset=utf-8
      ****Link: <http://api.example.com/doc/>; rel="http://www.w3.org/ns/hydra/core#apiDocumentation"****
      -->
    </pre>

    <p>The response in the example above contains an HTTP Link Header
      pointing to <code>http://api.example.com/doc/</code>.
      Retrieving that resource, the client would obtain a
      <a>Hydra API documentation</a> defining the API's main entry
      point:</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Retrieving a Hydra API documentation to obtain the main entry point">
      <!--
      GET /doc/ HTTP/1.1
      Host: api.example.com
      Accept: application/ld+json

      ====================================

      HTTP/1.1 200 OK
      ...
      Content-Type: application/ld+json

      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/doc/",
        "title": "The example.com API",
        ****"entrypoint": "http://api.example.com/"****,
        ...
      }
      -->
    </pre>

    <p>Please note that in most cases the entry point will already be
      known to the client. Thus, the discovery of the API documentation
      using HTTP Link Headers is typically not necessary as the concepts
      used in responses from the API will dereference to their
      documentation.</p>

    <p>In another scenario the <i>ApiDocumentation</i> would be discovered from
      a bookmarked resource's representation. Api implementation SHOULD emit
      the HTTP <i>Link</i> header on every Api response, making
      the <i>ApiDocumentation</i> (and entry points it defines) discoverable
      all the time.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Retrieving a Hydra API documentation from another Api response">
      <!--
      GET /api/items HTTP/1.1
      Host: api.example.com
      Accept: application/ld+json

      ====================================

      HTTP/1.1 200 OK
      ...
      Content-Type: application/ld+json
      ****Link: <http://api.example.com/doc/>; rel="http://www.w3.org/ns/hydra/core#apiDocumentation"****

      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/api/items",
        "title": "Items collection",
        ...
      }
      -->
    </pre>
  </section>

  <section>
    <h3>Api versions</h3>

    <p>It is common to provide a separate API address after a breaking changes
      update. This prevents current clients not to get broken as these may not
      support these changes.</p>

    <p>With hypermedia provided in each response payload, it may be unnecessary
      to provide such an alternative API. This is due to fact the client follows
      what the server provides and with proper margin for errors implemented
      within that client, even breaking changes can be published on the fly.</p>

    <p>Still, Hydra does neither have any special support for API versions, nor
      prevents them. It's fully an implementers decision on if and how
      to provide the API features.</p>
  </section>
</section>

<section>
  <h2>Advanced Concepts</h2>

  <p class="issue">Describe Hydra's Resource class? Or should that better be
    described somewhere in the beginning?</p>

  <section>
    <h3 name="collections">Collections</h3>

    <p>In many situations, it makes sense to expose resources that reference
      a set of somehow related resources. Results of a search query or
      entries of an address book are just two examples. To simplify such
      use cases, Hydra defines the two classes <i>hydra:Collection</i> and
      <i>hydra:PartialCollectionView</i>.</p>

    <p>A <i>hydra:Collection</i> can be used to reference a set of resources
      as follows:</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Referencing related resources using a Hydra Collection">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/an-issue/comments",
        ****"@type": "Collection"****,
        ****"totalItems": 4980****,
        ****"member"****: [
          {
            "@id": "/comments/429"
          },
          {
            "@id": "/comments/781",
            "title": "Properties may be embedded directly in the collection"
          },
          ...
        ]
      }
      -->
    </pre>

    <p>As shown in the example above, member items can either consist of
      solely a link or also include some properties. In some cases embedding
      member properties directly in the collection is beneficial as it may
      reduce the number of HTTP requests necessary to get enough information
      to process the result.</p>

    <p>Since collections may become very large, Web APIs often chose to
      split a collection into multiple pages. In Hydra, that can be achieved
      with a <i>hydra:PartialCollectionView</i>. It describes a specific
      view on the collection which represents only a subset of the collection's
      members. A <i>PartialCollectionView</i> may contain links to the
      <i>first</i>, <i>next</i>, <i>previous</i>, and <i>last</i>
      <i>PartialCollectionView</i> which allows a client to find all members
      of a <i>Collection</i>.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="A Hydra PartialCollectionView splits a collection into multiple views">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/an-issue/comments",
        "@type": "Collection",
        "totalItems": 4980,
        "member": [
          ####... a subset of the members of the Collection ...####
        ],
        ****"view"****: {
          "@id": "http://api.example.com/an-issue/comments?page=3",
          ****"@type": "PartialCollectionView"****,
          ****"first": "/an-issue/comments?page=1"****,
          ****"previous": "/an-issue/comments?page=2"****,
          ****"next": "/an-issue/comments?page=4"****,
          ****"last": "/an-issue/comments?page=498"****
        }
      }
      -->
    </pre>

    <p class="issue">Say that all these properties are optional? What about
      <i>first</i> and, perhaps more interestingly, <i>last</i>?</p>
  </section>

  <section>
    <h4>Member assertions</h4>

    <p>A <i>memberAssertion</i> is a way to declare additional, implicit statements about
      members of a <a href="#collections">collection</a>. Statements which may otherwise
      be missing from the respective member resources inlined in a collection's
      representation.</p>

    <pre class="example nohighlight"
         data-transform="updateExample"
         title="Member assertion describes relation with another resource">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/an-issue/comments",
        "@type": "Collection",
        ****"memberAssertion": {
          "subject": "http://api.example.com/an-issue",
          "property": "http://api.example.com/vocab#comment"
        }****,
        "member": [
          {
            "@id": "/comments/429"
          }
        ]
      }
      -->
    </pre>

    <p>In the above example, adding a <code>memberAssertion</code> node to the collection instructs the
      client that every member of this collection is linked to the <code>subject</code>
      by the <code>property</code>. It could be written as a SPARQL triple pattern below, where
      <code>?m</code> would be substituted by each member of the collection.</p>

    <pre class="example nohighlight" data-transform="updateExample">
      <!--
      <http://api.example.com/an-issue> <http://api.example.com/vocab#comment> ?m
      -->
    </pre>

    <p>A <i>memberAssertion</i> MUST use two and only two of the <code>subject</code>, <code>property</code>
      and <code>object</code> predicates. There <code>memberAssertion</code> predicate MAY have more than one
      such blocks, each expressing different relations between the collection members and other resources.</p>

    <p class="note">It's important to point out that the <code>subject</code>, <code>property</code>
      and <code>object</code> predicates are defined within the Hydra namespace and are not
      <a href="https://www.w3.org/TR/rdf-schema/"><code>rdf</code></a> terms.</p>

    <p>It is also possible to use <i>memberAssertion</i> predicate on the API documentation level,
      by attaching this predicate to subclasses of the <i>Collection</i>, like in the example below.
      Clients would understand that all members of collections which are instances of <i>api:UserCollections</i>
      would in fact have <i>rdf:type api:User</i>.</p>

    <pre class="example nohighlight"
         data-transform="updateExample"
         title="Member assertion block describes strongly typed collection">
      <!--
      {
        "@context": [
          "http://www.w3.org/ns/hydra/context.jsonld",
          { "api": "http://api.example.com/api/documentation#" }
        ],
        "@id": "http://api.example.com/api/documentation",
        "@type": "ApiDocumentation",
        "supportedClass": [api:User, api:UserCollection],
        "api:UserCollection": {
          "subClassOf": "Collection",
          ****"memberAssertion": {
            "property": "rdf:type",
            "object": "api:User"
          }****,
        }
      }
      -->
    </pre>

    <p>It is worth to mention that a strongly typed collection instance can have its own
      member assertions. In such scenario, both <i>API documentation</i> level and instance
      level assertions should be combined as neither makes the other obsolete.</p>

    <p>More complex scenario would involve a class hierarchy, in which each class can
      carry additional member assertions compared to it's base class. To discover all
      available member assertion blocks client SHOULD traverse whole class hierarchy
      to gather all of the member assertions. In order to take such a burden from clients
      it is strongly recommended to provide all member assertion blocks to be provided
      on each class level including it's base class blocks so the client does not have
      to perform this traversing behavior.</p>
  </section>

  <section>
    <h3>Templated Links</h3>

    <p>Sometimes, it is impossible for a server to construct a URL because
      the URL depends on information only known by the client. A typical
      use case are URLs which enable a client to query the server. In such
      a case, the server cannot construct the URL because it does not know
      the query the client is interested in. What the server can do however,
      is to give the client a template to construct such a URL at runtime.
      In Hydra, the <i>IriTemplate</i> class is used to do so.</p>

    <p>An <i>IriTemplate</i> consists of a <i>template</i> literal and a set
      of <i>mappings</i>. Each <i>IriTemplateMapping</i> maps a
      <i>variable</i> used in the template to a <i>property</i> and may
      optionally specify whether that variable is <i>required</i> or not.
      The syntax of the template literal is specified by its datatype and
      defaults to the [[!RFC6570]] URI Template syntax, which can be
      explicitly indicated by <i>hydra:Rfc6570Template</i>.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Description of an IRI Template">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        ****"@type": "IriTemplate"****,
        ****"template": "http://api.example.com/issues{?q}"****,
        ****"variableRepresentation": "BasicRepresentation"****,
        ****"mapping"****: [
          {
            ****"@type": "IriTemplateMapping"****,
            ****"variable": "q"****,
            ****"property": "hydra:freetextQuery"****,
            ****"required": true****
          }
        ]
      }
      -->
    </pre>

    <p>The example above maps the variable <code>q</code> to Hydra's
      <i>freetextQuery</i> property and marks it as required.
      As its name suggests, the <i>freetextQuery</i> property can be used
      for free text queries.</p>

    <p>A template syntax only details how to fill out simple string values,
      but not how to derive such string values from typed values,
      language-tagged strings, or IRIs. Hydra addresses this by
      specifying how such values are to be serialized as strings. The
      serialization of an <i>IriTemplate's</i> variables can be described
      by setting the <i>variableRepresentation</i> property to
      <i>BasicRepresentation</i> or <i>ExplicitRepresentation</i>. The
      <i>BasicRepresentation</i> represents values by their lexical form. It
      omits type and language information and does not differentiate between
      IRIs and literals. The <i>ExplicitRepresentation</i>, on the other
      hand, includes type and language information and differentiates
      between IRIs and literals by serializing values as follows:</p>

    <ul>
      <li>IRIs are represented as-is.</li>
      <li>Literals, i.e., (typed) values and language-tagged strings are
        represented by their lexical form, surrounded by a single pair of
        doubles quotes (<code>"</code>).</li>
      <li>If a literal has a language, a single <code>@</code> symbol is
        appended after the double-quoted lexical form, followed by a
        non-empty [[BCP47]] language code.</li>
      <li>If a literal has a type, two <em>caret</em> symbols
        (<code>^^</code>) are appended after the double-quoted literal,
        followed by the full datatype IRI.</li>
    </ul>

    <p>In both representations characters MUST NOT be escaped. In case the
      representation format is not explicitly described, clients SHOULD
      use the <i>BasicRepresentation</i> by default.</p>

    <p class="warning">Although <i>ExplicitRepresentation</i> use of
      <code>@</code> and <code>^^</code> is similar, it is <em>not</em> the
      same as the [[Turtle]] representation for literals. Turtle literals
      require escaping of special characters, surround datatype IRIs with
      angular brackets (<code>&lt;</code> and <code>&gt;</code>), and also
      allow single quotes (<code>'</code>) to indicate literals.
      <i>ExplicitRepresentation</i> values must not be escaped, IRIs must
      not be surrounded by any character, and only double quotes can
      indicate literals.</p>

    <p>Below are some example values serialized in the different
      representations as well as the result of expanding the IRI template
      <code>http://example.com/find/{value}</code> with the respective
      value.</p>

    <aside class="example nohighlight" title="The different variable representations">
      <dl>
        <dt>The IRI <code>http://www.hydra-cg.com/</code></dt>
        <dd>BasicRepresentation: <code>http://www.hydra-cg.com/</code>; resulting IRI:
          <code>http://example.com/find/http%3A%2F%2Fwww.hydra-cg.com%2F</code></dd>
        <dd>ExplicitRepresentation: <code>http://www.hydra-cg.com/</code>; resulting IRI:
          <code>http://example.com/find/http%3A%2F%2Fwww.hydra-cg.com%2F</code></dd>

        <dt>The string <code>A simple string</code></dt>
        <dd>BasicRepresentation: <code>A simple string</code>; resulting IRI:
          <code>http://example.com/find/A%20simple%20string</code></dd>
        <dd>ExplicitRepresentation: <code>"A simple string"</code>; resulting IRI:
          <code>http://example.com/find/%22A%20simple%20string%22</code></dd>

        <dt>The string <code>A string " with a quote</code></dt>
        <dd>BasicRepresentation: <code>A string " with a quote</code>; resulting IRI:
          <code>http://example.com/find/A%20string%20%22%20with%20a%20quote</code></dd>
        <dd>ExplicitRepresentation: <code>"A string " with a quote"</code>; resulting IRI:
          <code>http://example.com/find/%22A%20string%20%22%20with%20a%20quote%22</code></dd>

        <dt>The language-tagged string <code>A simple string</code> with language English</dt>
        <dd>BasicRepresentation: <code>A simple string</code>; resulting IRI:
          <code>http://example.com/find/A%20simple%20string</code></dd>
        <dd>ExplicitRepresentation: <code>"A simple string"@en</code>; resulting IRI:
          <code>http://example.com/find/%22A%20simple%20string%22%40en</code></dd>

        <dt>The decimal value <code>5.5</code></dt>
        <dd>BasicRepresentation: <code>5.5</code>; resulting IRI: <code>http://example.com/find/5.5</code></dd>
        <dd>ExplicitRepresentation: <code>"5.5"^^http://www.w3.org/2001/XMLSchema#decimal</code>; resulting IRI:
          <code>http://example.com/find/%225.5%22%5E%5Ehttp%3A%2F%2Fwww.w3.org%2F2001%2FXMLSchema%23decimal</code></dd>
      </dl>
    </aside>

    <p>Similar to how Hydra's <i>Link</i> class allows the definition of
      properties that represent hyperlinks as described in
      <a class="sectionRef" href="#adding-affordances-to-representations"></a>,
      the <i>TemplatedLink</i> class allows the definition of properties
      whose value are IRI templates. Hydra predefines one such property,
      namely the <i>search</i> property which can be used to document
      available search interfaces.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="The definition of Hydra's search property (extract)">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "****hydra:search****",
        ****"@type": "hydra:TemplatedLink"****
      }
      -->
    </pre>

    <p>IRI expansion should be performed with respect to the specification
      behind the IRI template type (RFC 6570 by default), and the product
      of this process SHOULD be an IRI. When the produced IRI is relative,
      the client SHOULD stick to RFC 3986 sections 5.1.3 and 5.1.4 to be compatible
      with most RDF serializations that support relative IRIs. Still, it may be
      preferred to use another base URI for the expansion process, which
      makes the <i>resolveRelativeTo</i> term useful. It allows to switch the
      IRI template expansion algorithm so the base URI is established using
      current link context, which is a subject of the relation pointing to an
      <i>IriTemplate</i> instance. In case that subject is a relative URI,
      default behavior SHOULD be used as fallback.</p>

    <p>The example below allows to make the product of an IRI template
      expansion relative to the <i>http://api.example.com/an-issue/</i> resource
      by using it as its base URI, which further enables the <i>some:operation</i> to
      be moved to i.e. API documentation level rather to inline it.</p>

    <pre class="example nohighlight"
         data-transform="updateExample"
         title="Custom base Uri resolution for an Iri template">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/an-issue/",
        "@type": "Collection",
        "some:operation": {
          "@type": "IriTemplate",
          "template": "{id}",
          "resolveRelativeTo": "LinkContext",
          "variable": "id",
          "mapping": {...}
        }
      }
      -->
    </pre>

    <p>When constructed, the IRI would effectively become similar to <code>http://api.example.com/an-issue/1234</code>,
      with the relative part <code>{id}</code> appended to the link context URL.</p>
  </section>

  <section>
    <h3>IRI template operations</h3>

    <p>There are circumstances in which client would like to perform an operation
      not knowing the final IRI of the resource to be called. This case is especially
      in force when working with collections - client may want to add a new
      collection member, or it may need to provide more details while searching
      with other protocol's method (i.e. POST instead of GET in case of an HTTP).</p>

    <p>This is achievable by attaching a <i>supportedOperation</i> to the property
      that connects a subject of that relation with its <i>IRI template</i>
      as described in the previous part of this document. Please note that
      client is still allowed to use the defined link and custom operation's
      method is optional.</p>

    <pre class="example nohighlight"
         data-transform="updateExample"
         title="Operation with IRI template">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/api-documentation",
        "@type": "ApiDocumentation",
        ****"api:search": {
          "@type": "Link",
          "rdfs:subClassOf": "search",
          "supportedOperation": {
            "@type": "SupportedOperation",
            "method": "POST"
          }****
      }

      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/issues",
        "@type": "Collection",
        ****"api:search": {
          "@type": "IriTemplate",
          "template": "/issues?search={name}",
          "mapping": {...}****
      }
      -->
    </pre>

    <p>The example above allows client to either invoke an HTTP GET or POST
      call on <i>http://api.example.com/issues?search=search_string</i> resource.</p>

    <pre class="example nohighlight"
         data-transform="updateExample"
         title="Operation with IRI template without link option">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/api-documentation",
        "@type": "ApiDocumentation",
        ****"api:find": {
          "supportedOperation": {
            "@type": "SupportedOperation",
            "method": "POST"
          }****
      }

      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/issues",
        "@type": "Collection",
        ****"api:search": {
          "@type": "IriTemplate",
          "template": "/issues?find={name}",
          "mapping": {...}****
      }
      -->
    </pre>

    <p>The example above allows client to invoke only an HTTP POST
      call on <i>http://api.example.com/issues?find=search_string</i> resource as
      the described relation of <i>find</i> is not a <i>Link</i>.</p>
  </section>

  <section>
    <h3>Supported property data source</h3>

    <p>There are circumstances in which an API would like to inform a client on
      when to obtain values to feed data structures with details. Having all the
      necessary components like supported property, collection and IRI templates,
      it is possible to drive the client and direct it with links and operations
      to the data sources.</p>

    <p>It is doable by attaching either a <i>collection</i> or <i>search</i>
      predicate to instance of <i>supportedProperty</i> or to <i>property</i>.
      In such case client SHOULD use assume that the relation leads to
      the collection of values compatible with the supported property's range
      and can be used to feed data structures with the supported property.
      It is recommended (but not mandatory) to use <i>freetextQuery</i>
      variable mapping in case of the <i>search</i> predicate as it has a
      well defined semantics and takes the burden of interpretation from
      the client.</p>

    <p>While it is possible to provide such links in both API documentation
      and within the received payload, client SHOULD use the latter link first
      if applicable. This is due to fact the the server may want to put additional
      context to narrow the collection of viable values. Redefinition does not
      make the more general one obsolete though and and can be used as a fallback.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Supported property data source">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@type": "****ApiDocumentation",
        "supportedClass": {
          "@id": "schema:Event",
          "supportedProperty": {
            "property": "schema:actor",
            "****search": {
              "template": "/api/user{?search}",
              "mapping": {
                "variable": "search",
                "property": "freetextQuery"
              }
            }****
          }
        },
        ...
      }
      -->
    </pre>

    <p>The example above instructs a client that every resource of type
      <i>schema:Event</i> can have a relation of <i>schema:actor</i>, the objects of which the
      client can obtain using the search link provided.</p>
  </section>

  <section>
    <h3>Description of HTTP Status Codes and Errors</h3>

    <p>HTTP status codes have well defined semantics and can be used to
      signal the outcome of an operation. Unfortunately, however, HTTP
      status codes by themselves are often not specific enough, making it
      difficult to understand the real cause of an error. For
      instance, a <code>429 Too Many Requests</code> response is rarely
      informative enough by itself. To address this issue, Hydra defines
      a <i>Status</i> class which allows additional
      information to be associated with an HTTP status code.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Associating additional information to an HTTP status code">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@type": "****Status****",
        ****"statusCode": 429****,
        "title": "Too Many Requests",
        "description": "A maximum of 500 requests per hour and user is allowed.",
        ...
      }
      -->
    </pre>

    <p>An <i>ApiDocumentation</i> or an <i>Operation</i> may document the
      status codes that might be returned by the server using the
      <i>possibleStatus</i> property as described in
      <a class="sectionRef" href="#documenting-a-web-api"></a>. This allows
      a developer to understand what to expect when invoking an operation.
      It has, however, not to be considered as an extensive list of all
      potentially returned status codes; it is merely a hint. Developers
      should expect to encounter other HTTP status codes as well.</p>

    <p>A server may also return a <i>Status</i> directly in
      a response. When doing so, it often makes sense to subclass the
      <i>Status</i> to make its semantics more explicit.
      Hydra defines just one such subclass, namely the <i>Error</i> class.
      This provides an extensible framework to communicate error details to
      a client.</p>

    <p>Furthermore, a <i>Status</i> or <i>Error</i> returned by the server can also
      be given an identifier. When dereferenced, the <i>Error</i> resource can provide
      more detailed information or possible ways to resolve the problem, if applicable.<p/>

    <p>Finally, the server SHOULD provide error descriptions using an [[!RFC7807]] standard
      by using an <i>application/problem+json</i> response. When doing so, the server also MUST provide
      an additional header pointing to either the built-in Hydra <i>http://www.w3.org/ns/hydra/error</i>
      context or any JSON-LD context that maps the terms <i>type</i>, <i>title</i>, <i>detail</i>,
      <i>status</i> and <i>instance</i> the same way as the standard one.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="RFC-7807 compatible error description">
      <!--
      HTTP/1.1 400 Bad Request
      Content-Type: application/problem+json
      Link: <http://www.w3.org/ns/hydra/error>; rel="http://www.w3.org/ns/json-ld#context"

      {
        "type": "https://example.com/probs/out-of-credit",
        "@type": "http://www.w3.org/ns/hydra/core#Error",
        "title": "You do not have enough credit.",
        "detail": "Your current balance is 30, but that costs 50.",
        "instance": "/account/12345/msgs/abc",
        "balance": 30,
        "accounts": ["/account/12345",
                     "/account/67890"]
      }
      -->
    </pre>

    <p>While the built-in context makes the response fully compatible with the mentioned specification,
      properties not defined in the standard Hydra's error context won't be visible for Hydra aware processors.
      To overcome this, it is possible to declare a custom context pointed the same way, that would combine standard
      Hydra's standard error context and an additional JSON-LD context with either the <i>@vocab</i>
      or custom property mappings telling the processor on how to interpret those custom error properties.</p>

    <p>Resources provided may have an additional hint pointing to an <i>Error</i> type like in the example
      above, but it is not mandatory to do so as all resources described with <i>application/problem+json</i>
      are considered <i>hydra:Error</i>.</p>

    <p>It is worth to mention that it may happen (i.e. due to proxy behavior) the value of the <i>status</i> property
      will differ to the one received from the protocol layer.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Non RFC-7807 compliant error description using raw Hydra JSON-LD representation.">
      <!--
      HTTP/1.1 400 Bad Request
      Content-Type: application/ld+json

      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@type": "****Error****",
        "@id": "http://api.example.com/error-details/1234",
        "title": "An error occurred",
        "description": "Typically, a specialization of this class is used in practice.",
        ...
      }
      -->
    </pre>
  </section>

  <section>
    <h3>Client initiated pagination</h3>

    <p>There are situations when a client would like to provide a specific
      collection limitations, i.e. by providing query-language like member
      offset and limit or some specific page index and number of members
      per page. This is doable with <i>offset</i>/<i>limit</i> or
      <i>pageIndex</i>/<i>limit</i> predicates.</p>

    <p>With those, it is possible to bind a template variables mapped
      with externally obtained values (i.e. user interaction) the same way
      as with other mappings.</p>

    <p>While the predicates enlisted above accepts non-negative integer
      numbers, there is also a possibility of providing a custom page
      reference expressed via <i>pageReference</i> predicate. It is possible
      to provide a custom page identifier (i.e. a GUID or a letter)
      instead of a number.</p>
  </section>

  <section>
    <h3>Extensions</h3>
    <p>While Hydra Core Vocabulary allows addressing many usage scenarios,
      not every aspect of API behavior can be covered. This
      applies especially to querying, resource projection or data structure
      description. This is due to fact that Hydra is meant to be as light
      as possible forcing to drop some of the features out of its scope.</p>

    <p>That is why there is a possibility of hinting a client on what kind
      of extensions may be found or used in the received payloads.
      After discovering an <i>extension</i> predicate in the API documentation,
      client can assume additional details are available described with
      complementary vocabularies.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Hydra client extension usage.">
      <!--
      {
        "@context": "http://www.w3.org/ns/hydra/context.jsonld",
        "@id": "http://api.example.com/doc/",
        "@type": "ApiDocumentation",
        "title": "The name of the API",
        "description": "A short description of the API",
        "entrypoint": "URL of the API's main entry point",
        ****"extension": "http://www.w3.org/ns/shacl#"****,
        ...
      }
      -->
    </pre>

    <p>It is up to the used vocabulary to define how these additional details should be
      interpreted. In case client does not recognize these extensions,
      additional details should be ignored and base Hydra interpretation
      should be in force.</p>

    <p>Server SHOULD NOT use extensions to add statements that are in
      contradiction to base Hydra interpretation so the client is not confused.
      Server SHOULD also keep multiple extensions describing adequate
      knowledge in line regarding their description (i.e. data structure
      descriptions in various vocabularies should not cause differences).</p>

    <p>Client can express its preferences through the <i>Prefer</i> HTTP header
      by pointing the preferred extensions via IRIs as on the example below.
      The client SHOULD use the <i>Prefer</i> HTTP header [[!RFC7240]] with
      the <i>hydra.extension</i> preference as an <i>iri</i> attribute having
      the IRI of the extension as value to hint the server about the extension
      it supports. Multiple preferences can be expressed by providing multiple
      <i>Prefer</i> header values.</p>

    <pre class="example nohighlight" data-transform="updateExample"
         title="Hydra client extension preference.">
      <!--
      GET http://api.example.com/api/people
      ****Prefer: hydra.extension; iri="http://schema.org/"****
      -->
    </pre>

    <p>Server MUST implement <i>Prefer</i> header handling according to
      the [[!RFC7240]] and implementers should proceed with caution.</p>
  </section>
</section>

<!-- <section>
  <h2>Using Hydra Descriptions as JSON</h2>

  <p class="issue">The are multiple ways to serialize a
    <a>Hydra API documentation</a> in JSON-LD. To make it usable also for
    plain-old JSON clients, the serialization has to have a deterministic
    shape. The definition of a profile will make it possible to signal
    or request specific serialization conventions at the media type
    level. The definition of the profile might be as simple as defining
    a JSON-LD frame.</p>
</section> -->

<section>
  <h2>Classes</h2>

  <div id="vocabulary-classes"></div>
</section>

<section>
  <h2>Properties</h2>

  <div id="vocabulary-properties"></div>
</section>

<section class="informative">
  <h2>Acknowledgements</h2>

  <p>The authors would like to thank the following individuals for contributing
    their ideas and providing feedback for writing this specification:
    Arnau Siches, elf Pavlik, Karol Szczepański, Mark Baker, Martijn Faassen,
    Matthias Lehmann, Ruben Verborgh, Ryan J. McDonough, Sam Goto,
    Thomas Hoppe, Tomasz Pluskiewicz, @wasabiwimp (on GitHub).</p>
</section>

<section class="appendix informative">
  <h2>The Hydra Core Vocabulary in JSON-LD</h2>

  <pre id="vocabulary-jsonld">
  </pre>
</section>

</body>
</html>
